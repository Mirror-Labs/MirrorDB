import { createDB } from "src/Datalog/Example/DumbEngine";
import { Attribute, TrippleFact } from "src/Datalog/Types";
import { Schema } from "./MirrorDB";
import uuid from "uuid";
import { Schema as EntitySchema } from "./Schema";

export interface Transaction {
  add(
    entitySchema: EntitySchema,
    addOp: Record<string, MirrorDBValue | Ref | undefined>
  ): Ref;
  update(entity: string, updateInput: UpdateInput): TempRef;
}

export type UpdateInput = {
  find: Record<string, MirrorDBValue | TempRef | undefined>;
  update: Record<string, MirrorDBValue | TempRef | undefined>;
};

class TransactionImpl implements Transaction {
  private _operations: Operation[];
  private _tempRefs: Set<TempRef>;

  constructor(private schema: Schema) {
    this._operations = [];
    this._tempRefs = new Set();
  }

  get operations(): Operation[] {
    return this._operations;
  }

  get tempRefs(): Set<TempRef> {
    return this._tempRefs;
  }

  public add(
    entitySchema: any,
    entries: Record<string, MirrorDBValue | Ref | undefined>
  ): Ref {
    // Throws is it doesn't match
    matchOnAdd(entitySchema, entries);
    const id = uuid.v4();
    const autoTripples = createAutos(id, entitySchema);
    const customTripples = create(id, entitySchema.name, entries);

    this._operations.push({
      kind: "AddOp",
      ref: id,
      tripples: [...autoTripples, ...customTripples],
    });

    return id;
  }

  public update(entity: string, updateOp: UpdateInput): TempRef {
    return { kind: "TempRef", ref: "" };
  }
}

function createAutos(id: string, entitySchema: any): TrippleFact[] {
  const tripples: TrippleFact[] = [];
  for (const trippleSchema of entitySchema.allAutos()) {
    // Only datetimes are allowed to be autogenerated according to Schema
    const value = new Date();
    tripples.push(
      new TrippleFact(id, trippleSchema.attributeName, value.getTime())
    );
  }
  return tripples;
}

class MissingAttributeError extends Error {
  constructor(message: string, public attr: string) {
    super(message);
  }
}
class InvalidValueError extends Error {
  constructor(
    message: string,
    public attr: string,
    public value: MirrorDBValue,
    public schema: any
  ) {
    super(message);
  }
}

function matchOnAdd(
  values: Record<string, MirrorDBValue | Ref | undefined>,
  entitySchema: any
): void {
  for (const [key, value] of Object.entries(values)) {
    const trippleSchema = entitySchema.get(key);
    if (trippleSchema === undefined) {
      throw new MissingAttributeError("Attribute is missing", key);
    }
    if (value !== undefined && !trippleSchema.match(value)) {
      throw new InvalidValueError(
        "value does not match schema",
        key,
        value,
        trippleSchema
      );
    }
  }
}

function create(
  id: string,
  attrPrefix: string,
  values: Record<string, MirrorDBValue | Ref | undefined>
): TrippleFact[] {
  const tripples: TrippleFact[] = [];
  for (const [key, value] of Object.entries(values)) {
    if (value !== undefined) {
      tripples.push(new TrippleFact(id, `${attrPrefix}/${key}`, value));
    }
  }
  return tripples;
}

type DB = TrippleFact[];

type TempRef = {
  kind: "TempRef";
  ref: string;
};

type Ref = string;

type Operation = AddOp | UpdateOp;

type MirrorDBValue = string | number | boolean;

type AddOp = {
  kind: "AddOp";
  ref: Ref;
  tripples: TrippleFact[];
};

type UpdateOp = {
  kind: "UpdateOp";
  entity: string;
  find: [string, MirrorDBValue | Ref];
  values: Record<string, MirrorDBValue | TempRef | undefined>;
};

// export function transact(
//   f: (tx: Transaction) => void,
//   db: DB,
//   schema: Schema,
//   genRef: () => string
// ): DB {
//   const tx = new TransactionImpl(schema);

//   f(tx);

//   const mapRefs: Map<string, Ref> = new Map();

//   const newTripples: [Ref, Attribute, MirrorDBValue | TempRef][] = [];
//   const toRemove: [any, any][] = [];
//   for (const op of tx.operations) {
//     if (op.kind === "AddOp") {
//       const ref = genRef();
//       mapRefs.set(op.ref, ref);
//       const namespace = op.entity;
//       for (const attr of Object.keys(op.values)) {
//         const value = op.values[attr];
//         const fullAttr = `:${namespace}/${attr}`;
//         if (value !== undefined) {
//           newTripples.push([ref, fullAttr, value]);
//         }
//       }
//     } else if (op.kind === "UpdateOp") {
//       const findAttr = op.find[0];
//       const findValue = op.find[1];
//       let oldFact;
//       for (const fact of db) {
//         if (fact.attribute === findAttr && fact.value === findValue) {
//           oldFact = fact;
//         }
//       }

//       if (oldFact) {
//         const ref = oldFact.entity;
//         const namespace = op.entity;
//         for (const attr of Object.keys(op.values)) {
//           const value = op.values[attr];
//           const fullAttr = `:${namespace}/${attr}`;
//           if (value !== undefined) {
//             newTripples.push([ref, fullAttr, value]);
//             toRemove.push([ref, fullAttr]);
//           }
//         }
//       }
//     }
//   }

//   for (const newFact of newTripples) {
//     const value = newFact[2];
//     if (typeof value === "object" && value.kind === "TempRef") {
//       const tempRef = newFact[2] as TempRef;
//       newFact[2] = mapRefs.get(tempRef.ref)!;
//     }
//   }

//   const newDb = db.filter(
//     (fact) =>
//       toRemove.filter(
//         (removeFact) =>
//           removeFact[0] === fact.entity && removeFact[1] === fact.attribute
//       ).length === 0
//   );

//   for (const newFact of newTripples) {
//     newDb.push(
//       new TrippleFact(newFact[0], newFact[1], newFact[2] as MirrorDBValue | Ref)
//     );
//   }

//   return newDb;
// }
